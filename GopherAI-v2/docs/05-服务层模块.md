# 服务层模块 (service/)

## 1. 模块概述

服务层是业务逻辑的核心实现层，负责处理具体的业务规则，协调 DAO 层和通用模块，为控制器层提供业务功能接口。

## 2. 文件结构

```
service/
├── user/
│   └── user.go       # 用户业务服务
├── session/
│   └── session.go    # 会话业务服务
├── file/
│   └── file.go       # 文件业务服务
└── image/
    └── image.go      # 图像业务服务
```

## 3. 用户服务 (user/user.go)

### 3.1 Login - 用户登录

```go
func Login(username, password string) (string, error)
```

**功能**: 验证用户凭据并生成 JWT Token

**参数**:
| 参数 | 类型 | 说明 |
|------|------|------|
| username | string | 用户名（11位数字） |
| password | string | 密码明文 |

**返回值**:
| 返回值 | 类型 | 说明 |
|--------|------|------|
| token | string | JWT Token |
| error | error | 错误信息 |

**业务流程**:
```
1. 调用 dao.IsExistUser(username) 检查用户存在
   ├─ 不存在 → 返回 CodeUserNotExist 错误
   │
2. 获取用户信息
   │
3. 验证密码 utils.MD5(password) == user.Password
   ├─ 不匹配 → 返回 CodeInvalidPassword 错误
   │
4. 生成 JWT Token
   │
5. 返回 Token
```

**代码实现**:
```go
func Login(username, password string) (string, error) {
    // 检查用户是否存在
    user, exist := dao.IsExistUser(username)
    if !exist {
        return "", errors.New(code.CodeUserNotExist.Msg())
    }
    
    // 验证密码 (MD5 加密比较)
    if utils.MD5(password) != user.Password {
        return "", errors.New(code.CodeInvalidPassword.Msg())
    }
    
    // 生成 JWT Token
    token, err := myjwt.GenerateToken(user.ID, user.Username)
    if err != nil {
        return "", err
    }
    
    return token, nil
}
```

### 3.2 Register - 用户注册

```go
func Register(email, password string) (string, string, error)
```

**功能**: 注册新用户，生成唯一用户名和 JWT Token

**参数**:
| 参数 | 类型 | 说明 |
|------|------|------|
| email | string | 用户邮箱 |
| password | string | 密码明文 |

**返回值**:
| 返回值 | 类型 | 说明 |
|--------|------|------|
| token | string | JWT Token |
| username | string | 生成的11位用户名 |
| error | error | 错误信息 |

**业务流程**:
```
1. 调用 dao.IsExistUserByEmail(email) 检查邮箱
   ├─ 已存在 → 返回 CodeUserExist 错误
   │
2. 生成11位随机数字用户名
   │
3. 循环检查用户名是否已存在
   ├─ 已存在 → 重新生成
   │
4. 密码 MD5 加密
   │
5. 调用 dao.Register() 写入数据库
   │
6. 生成 JWT Token
   │
7. 返回 Token 和 Username
```

**代码实现**:
```go
func Register(email, password string) (string, string, error) {
    // 检查邮箱是否已注册
    _, exist := dao.IsExistUserByEmail(email)
    if exist {
        return "", "", errors.New(code.CodeUserExist.Msg())
    }
    
    // 生成唯一的11位用户名
    var username string
    for {
        username = utils.GetRandomNumbers(11)
        _, exist := dao.IsExistUser(username)
        if !exist {
            break
        }
    }
    
    // 注册用户 (密码 MD5 加密)
    user, err := dao.Register(username, email, utils.MD5(password))
    if err != nil {
        return "", "", err
    }
    
    // 生成 Token
    token, err := myjwt.GenerateToken(user.ID, user.Username)
    if err != nil {
        return "", "", err
    }
    
    return token, username, nil
}
```

## 4. 会话服务 (session/session.go)

### 4.1 GetUserSessionsByUserName - 获取用户会话列表

```go
func GetUserSessionsByUserName(userName string) ([]model.SessionInfo, error)
```

**功能**: 获取指定用户的所有会话列表

**返回数据**:
```go
type SessionInfo struct {
    SessionID string `json:"sessionId"`
    Title     string `json:"name"`
}
```

### 4.2 CreateSessionAndSendMessage - 创建会话并发送消息（同步）

```go
func CreateSessionAndSendMessage(userName, question, modelType string) (string, string, error)
```

**功能**: 创建新会话，发送消息并获取 AI 回复

**参数**:
| 参数 | 类型 | 说明 |
|------|------|------|
| userName | string | 用户名 |
| question | string | 用户问题 |
| modelType | string | AI 模型类型 (1/2/3/4) |

**返回值**:
| 返回值 | 类型 | 说明 |
|--------|------|------|
| sessionID | string | 新建的会话 ID |
| answer | string | AI 回复内容 |
| error | error | 错误信息 |

**业务流程**:
```
1. 生成 UUID 作为 sessionID
   │
2. 创建 Session 记录 (标题取问题前10字)
   │
3. 获取配置信息 config.GetConfig()
   │
4. 通过 AIHelperManager 获取或创建 AIHelper
   │
5. 调用 AIHelper.GenerateResponse() 获取回复
   │
6. 返回 sessionID 和 AI 回复
```

**代码实现**:
```go
func CreateSessionAndSendMessage(userName, question, modelType string) (string, string, error) {
    // 生成会话 ID
    sessionID := utils.GenerateUUID()
    
    // 创建会话记录
    title := question
    if len(title) > 10 {
        title = title[:10]
    }
    session := &model.Session{
        ID:       sessionID,
        UserName: userName,
        Title:    title,
    }
    dao.CreateSession(session)
    
    // 获取或创建 AIHelper
    cfg := config.GetConfig()
    manager := aihelper.GetGlobalManager()
    helper, err := manager.GetOrCreateAIHelper(
        userName, sessionID, modelType, cfg,
        func(msg *model.Message) (*model.Message, error) {
            // 消息持久化回调
            return saveMessageToQueue(msg)
        },
    )
    if err != nil {
        return "", "", err
    }
    
    // 获取 AI 回复
    answer, err := helper.GenerateResponse(userName, context.Background(), question)
    if err != nil {
        return "", "", err
    }
    
    return sessionID, answer, nil
}
```

### 4.3 CreateStreamSessionOnly - 仅创建会话（流式用）

```go
func CreateStreamSessionOnly(userName, question string) (string, error)
```

**功能**: 仅创建会话记录，不发送消息（用于流式场景先返回 sessionID）

### 4.4 StreamMessageToExistingSession - 流式发送消息

```go
func StreamMessageToExistingSession(
    userName, sessionID, question, modelType string,
    callback aihelper.StreamCallback,
) error
```

**功能**: 向已有会话流式发送消息

**参数**:
| 参数 | 类型 | 说明 |
|------|------|------|
| userName | string | 用户名 |
| sessionID | string | 会话 ID |
| question | string | 用户问题 |
| modelType | string | AI 模型类型 |
| callback | StreamCallback | 流式回调函数 |

**StreamCallback 定义**:
```go
type StreamCallback func(chunk string) error
```

**业务流程**:
```
1. 获取或创建 AIHelper
   │
2. 调用 helper.StreamResponse()
   │
3. 每收到一个 chunk，调用 callback(chunk)
   │
4. 完成后返回
```

### 4.5 ChatSend - 在已有会话发送消息（同步）

```go
func ChatSend(userName, sessionID, question, modelType string) (string, error)
```

**功能**: 在已有会话中发送消息并获取回复

### 4.6 ChatStreamSend - 在已有会话发送消息（流式）

```go
func ChatStreamSend(
    userName, sessionID, question, modelType string,
    callback aihelper.StreamCallback,
) error
```

**功能**: 在已有会话中流式发送消息

### 4.7 GetChatHistory - 获取聊天历史

```go
func GetChatHistory(userName, sessionID string) ([]model.History, error)
```

**功能**: 获取指定会话的消息历史

**返回数据**:
```go
type History struct {
    IsUser  bool   `json:"is_user"`   // true=用户消息, false=AI消息
    Content string `json:"content"`   // 消息内容
}
```

**业务流程**:
```
1. 验证会话是否属于该用户
   │
2. 从 AIHelperManager 获取内存中的消息
   ├─ 如果有 → 直接返回
   │
3. 否则从数据库查询
   │
4. 转换为 History 格式返回
```

## 5. 文件服务 (file/file.go)

### 5.1 UploadRagFile - 上传 RAG 文件

```go
func UploadRagFile(username string, file *multipart.FileHeader) (string, error)
```

**功能**: 上传文件到 RAG 知识库，创建向量索引

**参数**:
| 参数 | 类型 | 说明 |
|------|------|------|
| username | string | 用户名 |
| file | *multipart.FileHeader | 上传的文件 |

**支持的文件类型**:
- `.md` - Markdown 文件
- `.txt` - 纯文本文件

**业务流程**:
```
1. 校验文件类型 utils.ValidateFile(file)
   ├─ 不支持 → 返回错误
   │
2. 获取配置 config.GetConfig()
   │
3. 创建用户目录 {docDir}/{username}/
   │
4. 清理旧文件 utils.RemoveAllFilesInDir()
   │
5. 删除旧的向量索引 rag.DeleteIndex()
   │
6. 保存新文件
   │
7. 创建 RAG 索引器 rag.NewRAGIndexer()
   │
8. 执行文件索引 indexer.IndexFile()
   │
9. 返回文件保存路径
```

**代码实现**:
```go
func UploadRagFile(username string, file *multipart.FileHeader) (string, error) {
    // 验证文件类型
    if !utils.ValidateFile(file) {
        return "", errors.New("不支持的文件类型")
    }
    
    cfg := config.GetConfig()
    userDir := filepath.Join(cfg.RagDocDir, username)
    
    // 创建用户目录
    if err := os.MkdirAll(userDir, 0755); err != nil {
        return "", err
    }
    
    // 清理旧文件和索引
    utils.RemoveAllFilesInDir(userDir)
    rag.DeleteIndex(context.Background(), username)
    
    // 保存新文件
    filePath := filepath.Join(userDir, file.Filename)
    if err := saveUploadedFile(file, filePath); err != nil {
        return "", err
    }
    
    // 创建向量索引
    indexer, err := rag.NewRAGIndexer(username, cfg.RagEmbeddingModel)
    if err != nil {
        return "", err
    }
    
    if err := indexer.IndexFile(context.Background(), filePath); err != nil {
        return "", err
    }
    
    return filePath, nil
}
```

## 6. 图像服务 (image/image.go)

### 6.1 RecognizeImage - 图像识别

```go
func RecognizeImage(file *multipart.FileHeader) (string, error)
```

**功能**: 使用 ONNX 模型进行图像分类识别

**参数**:
| 参数 | 类型 | 说明 |
|------|------|------|
| file | *multipart.FileHeader | 上传的图片文件 |

**支持的图片格式**:
- `.jpg` / `.jpeg`
- `.png`
- `.gif`

**业务流程**:
```
1. 获取配置中的模型路径和标签路径
   │
2. 创建 ImageRecognizer 实例
   │
3. 读取上传文件内容到 buffer
   │
4. 调用 recognizer.PredictFromBuffer(buf)
   │
5. 关闭 recognizer 释放资源
   │
6. 返回分类结果
```

**代码实现**:
```go
func RecognizeImage(file *multipart.FileHeader) (string, error) {
    cfg := config.GetConfig()
    
    modelPath := cfg.ImageConfig.ModelPath
    labelPath := cfg.ImageConfig.LabelPath
    inputH, inputW := 224, 224
    
    // 创建识别器
    recognizer, err := image.NewImageRecognizer(modelPath, labelPath, inputH, inputW)
    if err != nil {
        log.Println("NewImageRecognizer fail:", err)
        return "", err
    }
    defer recognizer.Close()
    
    // 读取文件内容
    src, err := file.Open()
    if err != nil {
        return "", err
    }
    defer src.Close()
    
    buf, err := io.ReadAll(src)
    if err != nil {
        return "", err
    }
    
    // 执行预测
    return recognizer.PredictFromBuffer(buf)
}
```

## 7. 消息持久化机制

服务层通过消息队列异步持久化消息：

```go
// 消息保存回调函数
func saveMessageToQueue(msg *model.Message) (*model.Message, error) {
    // 生成消息队列参数
    param := cache.GenerateMessageParam(
        msg.SessionID,
        msg.Content,
        msg.UserName,
        msg.IsUser,
    )
    
    // 发布到消息队列
    cache.PublishMessage(param)
    
    return msg, nil
}
```

**消息队列流程**:
```
用户/AI 消息
      │
      ▼
  AIHelper.AddMessage()
      │
      ▼
  saveFunc 回调
      │
      ▼
  cache.PublishMessage()
      │
      ├── Redis 模式 → Redis Stream
      │
      └── BigCache 模式 → 内存 Channel
      │
      ▼
  消费者异步处理
      │
      ▼
  dao.CreateMessage() → MySQL
```

## 8. 依赖关系

```
service/
    ├── user/
    │   ├── → dao/user
    │   ├── → utils (MD5, GetRandomNumbers)
    │   ├── → utils/myjwt
    │   └── → common/code
    │
    ├── session/
    │   ├── → dao/session
    │   ├── → dao/message
    │   ├── → common/aihelper
    │   ├── → common/cache
    │   ├── → config
    │   ├── → model
    │   └── → utils
    │
    ├── file/
    │   ├── → common/rag
    │   ├── → config
    │   └── → utils
    │
    └── image/
        ├── → common/image
        └── → config
```

## 9. 注意事项

1. **会话隔离**: AIHelper 按 `用户名 + 会话ID` 隔离
2. **消息异步**: 消息通过队列异步持久化，保证响应速度
3. **资源释放**: ImageRecognizer 使用后需调用 Close()
4. **文件清理**: 上传新文件时会清理用户目录下的旧文件
5. **并发安全**: AIHelperManager 使用读写锁保证并发安全
