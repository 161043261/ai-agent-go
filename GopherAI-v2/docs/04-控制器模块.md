# 控制器模块 (controller/)

## 1. 模块概述

控制器层负责处理 HTTP 请求，包括请求参数解析、调用服务层、响应结果封装。遵循 MVC 架构模式，是请求和业务逻辑之间的桥梁。

## 2. 文件结构

```
controller/
├── common.go           # 通用响应结构定义
├── user/
│   └── user.go         # 用户认证控制器
├── session/
│   └── session.go      # AI 会话控制器
├── file/
│   └── file.go         # 文件上传控制器
└── image/
    └── image.go        # 图像识别控制器
```

## 3. 通用响应结构 (common.go)

### 3.1 Response 结构体

```go
type Response struct {
    StatusCode code.Code `json:"status_code"`          // 状态码
    StatusMsg  string    `json:"status_msg,omitempty"` // 状态消息（可选）
}
```

### 3.2 状态码说明

| 状态码 | 常量名 | 说明 |
|--------|--------|------|
| 1000 | CodeSuccess | 成功 |
| 2001 | CodeInvalidParams | 请求参数错误 |
| 2002 | CodeUserExist | 用户名已存在 |
| 2003 | CodeUserNotExist | 用户不存在 |
| 2004 | CodeInvalidPassword | 用户名或密码错误 |
| 2006 | CodeInvalidToken | 无效的 Token |
| 2007 | CodeNotLogin | 用户未登录 |
| 4001 | CodeServerBusy | 服务繁忙 |
| 5001 | AIModelNotFind | 模型不存在 |

## 4. 用户控制器 (user/user.go)

### 4.1 请求/响应结构

```go
// 登录请求
type LoginRequest struct {
    Username string `json:"username"`  // 用户名（11位数字）
    Password string `json:"password"`  // 密码
}

// 登录响应
type LoginResponse struct {
    controller.Response
    Token string `json:"token,omitempty"`  // JWT Token
}

// 注册请求
type RegisterRequest struct {
    Email    string `json:"email" binding:"required"`     // 邮箱（必填）
    Password string `json:"password" binding:"required"`  // 密码（必填）
}

// 注册响应
type RegisterResponse struct {
    controller.Response
    Token    string `json:"token,omitempty"`     // JWT Token
    Username string `json:"username,omitempty"`  // 生成的用户名
}
```

### 4.2 控制器函数

#### Register - 用户注册

```go
func Register(c *gin.Context)
```

**请求方式**: POST `/api/v1/user/register`

**请求参数**:
```json
{
    "email": "user@example.com",
    "password": "123456"
}
```

**响应示例**:
```json
{
    "status_code": 1000,
    "status_msg": "注册成功",
    "token": "eyJhbGciOiJIUzI1...",
    "username": "12345678901"
}
```

**处理流程**:
1. 解析请求 JSON
2. 调用 `service.Register(email, password)`
3. 返回生成的用户名和 Token

#### Login - 用户登录

```go
func Login(c *gin.Context)
```

**请求方式**: POST `/api/v1/user/login`

**请求参数**:
```json
{
    "username": "12345678901",
    "password": "123456"
}
```

**响应示例**:
```json
{
    "status_code": 1000,
    "status_msg": "登录成功",
    "token": "eyJhbGciOiJIUzI1..."
}
```

## 5. 会话控制器 (session/session.go)

### 5.1 请求/响应结构

```go
// 创建会话并发送消息请求
type CreateSessionAndSendMessageRequest struct {
    UserQuestion string `json:"question" binding:"required"`   // 用户问题
    ModelType    string `json:"modelType" binding:"required"`  // 模型类型
}

// 创建会话并发送消息响应
type CreateSessionAndSendMessageResponse struct {
    AiInformation string `json:"Information,omitempty"`  // AI 回复
    SessionID     string `json:"sessionId,omitempty"`    // 会话 ID
    controller.Response
}

// 发送消息请求
type ChatSendRequest struct {
    UserQuestion string `json:"question" binding:"required"`   // 用户问题
    ModelType    string `json:"modelType" binding:"required"`  // 模型类型
    SessionID    string `json:"sessionId" binding:"required"`  // 会话 ID
}

// 聊天历史请求
type ChatHistoryRequest struct {
    SessionID string `json:"sessionId" binding:"required"`  // 会话 ID
}

// 聊天历史响应
type ChatHistoryResponse struct {
    History []model.History `json:"history"`  // 消息历史列表
    controller.Response
}
```

### 5.2 模型类型说明

| 类型值 | 模型 | 说明 |
|--------|------|------|
| "1" | OpenAI | OpenAI 兼容 API |
| "2" | RAG | 知识库增强检索 |
| "3" | MCP | MCP 协议工具调用 |
| "4" | Ollama | 本地 Ollama 模型 |

### 5.3 控制器函数

#### GetUserSessionsByUserName - 获取会话列表

```go
func GetUserSessionsByUserName(c *gin.Context)
```

**请求方式**: GET `/api/v1/AI/chat/sessions`

**响应示例**:
```json
{
    "status_code": 1000,
    "status_msg": "success",
    "sessions": [
        {"sessionId": "uuid-1", "name": "会话标题1"},
        {"sessionId": "uuid-2", "name": "会话标题2"}
    ]
}
```

#### CreateSessionAndSendMessage - 创建会话并发送消息（同步）

```go
func CreateSessionAndSendMessage(c *gin.Context)
```

**请求方式**: POST `/api/v1/AI/chat/send-new-session`

**请求参数**:
```json
{
    "question": "你好，请介绍一下自己",
    "modelType": "1"
}
```

**响应示例**:
```json
{
    "status_code": 1000,
    "status_msg": "success",
    "Information": "你好！我是一个AI助手...",
    "sessionId": "550e8400-e29b-41d4-a716-446655440000"
}
```

#### CreateStreamSessionAndSendMessage - 创建会话并发送消息（流式）

```go
func CreateStreamSessionAndSendMessage(c *gin.Context)
```

**请求方式**: POST `/api/v1/AI/chat/send-stream-new-session`

**请求参数**: 同上

**响应格式**: Server-Sent Events (SSE)

```
Content-Type: text/event-stream

data: {"sessionId": "550e8400-e29b-41d4-a716-446655440000"}

data: {"content": "你好"}

data: {"content": "！我是"}

data: {"content": "一个AI助手"}

data: [DONE]
```

**实现逻辑**:
```go
func CreateStreamSessionAndSendMessage(c *gin.Context) {
    // 1. 设置 SSE 响应头
    c.Header("Content-Type", "text/event-stream")
    c.Header("Cache-Control", "no-cache")
    c.Header("Connection", "keep-alive")
    c.Header("X-Accel-Buffering", "no")
    
    // 2. 创建会话
    sessionID, _ := service.CreateStreamSessionOnly(userName, question)
    
    // 3. 先发送 sessionId
    c.Writer.WriteString(fmt.Sprintf("data: {\"sessionId\": \"%s\"}\n\n", sessionID))
    c.Writer.Flush()
    
    // 4. 流式发送 AI 回复
    service.StreamMessageToExistingSession(userName, sessionID, question, modelType,
        func(chunk string) {
            c.Writer.WriteString(fmt.Sprintf("data: {\"content\": \"%s\"}\n\n", chunk))
            c.Writer.Flush()
        })
    
    // 5. 发送结束标记
    c.Writer.WriteString("data: [DONE]\n\n")
    c.Writer.Flush()
}
```

#### ChatSend - 在已有会话发送消息（同步）

```go
func ChatSend(c *gin.Context)
```

**请求方式**: POST `/api/v1/AI/chat/send`

**请求参数**:
```json
{
    "sessionId": "550e8400-e29b-41d4-a716-446655440000",
    "question": "继续说一下",
    "modelType": "1"
}
```

#### ChatStreamSend - 在已有会话发送消息（流式）

```go
func ChatStreamSend(c *gin.Context)
```

**请求方式**: POST `/api/v1/AI/chat/send-stream`

**请求参数**: 同 ChatSend

**响应格式**: SSE 流式响应

#### ChatHistory - 获取聊天历史

```go
func ChatHistory(c *gin.Context)
```

**请求方式**: POST `/api/v1/AI/chat/history`

**请求参数**:
```json
{
    "sessionId": "550e8400-e29b-41d4-a716-446655440000"
}
```

**响应示例**:
```json
{
    "status_code": 1000,
    "status_msg": "success",
    "history": [
        {"is_user": true, "content": "你好"},
        {"is_user": false, "content": "你好！我是AI助手..."},
        {"is_user": true, "content": "继续说一下"},
        {"is_user": false, "content": "好的，我继续..."}
    ]
}
```

## 6. 文件控制器 (file/file.go)

### 6.1 控制器函数

#### UploadRagFile - 上传 RAG 文件

```go
func UploadRagFile(c *gin.Context)
```

**请求方式**: POST `/api/v1/file/upload`

**请求格式**: multipart/form-data

**表单字段**:
| 字段名 | 类型 | 说明 |
|--------|------|------|
| file | file | 上传的文件（支持 .md、.txt） |

**请求示例** (curl):
```bash
curl -X POST http://localhost:9090/api/v1/file/upload \
  -H "Authorization: Bearer <token>" \
  -F "file=@document.md"
```

**响应示例**:
```json
{
    "status_code": 1000,
    "status_msg": "success",
    "filePath": "./docs/username/document.md"
}
```

## 7. 图像控制器 (image/image.go)

### 7.1 控制器函数

#### RecognizeImage - 图像识别

```go
func RecognizeImage(c *gin.Context)
```

**请求方式**: POST `/api/v1/image/recognize`

**请求格式**: multipart/form-data

**表单字段**:
| 字段名 | 类型 | 说明 |
|--------|------|------|
| file | file | 上传的图片（支持 jpg、png、gif） |

**请求示例** (curl):
```bash
curl -X POST http://localhost:9090/api/v1/image/recognize \
  -H "Authorization: Bearer <token>" \
  -F "file=@image.jpg"
```

**响应示例**:
```json
{
    "status_code": 1000,
    "status_msg": "success",
    "result": "golden retriever"
}
```

## 8. 用户名获取

控制器通过 JWT 中间件设置的上下文获取当前用户：

```go
// 从 Context 获取用户名（JWT 中间件已解析）
userName, exists := c.Get("userName")
if !exists {
    c.JSON(http.StatusUnauthorized, controller.Response{
        StatusCode: code.CodeNotLogin,
        StatusMsg:  code.CodeNotLogin.Msg(),
    })
    return
}
```

## 9. 错误处理模式

```go
// 参数解析错误
if err := c.ShouldBindJSON(&req); err != nil {
    c.JSON(http.StatusOK, Response{
        StatusCode: code.CodeInvalidParams,
        StatusMsg:  code.CodeInvalidParams.Msg(),
    })
    return
}

// 服务层错误
result, err := service.SomeFunction()
if err != nil {
    c.JSON(http.StatusOK, Response{
        StatusCode: code.CodeServerBusy,
        StatusMsg:  err.Error(),
    })
    return
}

// 成功响应
c.JSON(http.StatusOK, SuccessResponse{
    Response: Response{
        StatusCode: code.CodeSuccess,
        StatusMsg:  "success",
    },
    Data: result,
})
```

## 10. 依赖关系

```
controller/
    ├── → common/code        (状态码)
    ├── → service/user       (用户服务)
    ├── → service/session    (会话服务)
    ├── → service/file       (文件服务)
    ├── → service/image      (图像服务)
    └── → model              (数据模型)
```

## 11. 注意事项

1. **参数验证**: 使用 Gin 的 `binding:"required"` 标签进行必填校验
2. **用户上下文**: 需要认证的接口从 `c.Get("userName")` 获取当前用户
3. **流式响应**: SSE 接口需要设置特定的 HTTP 头，禁用缓冲
4. **文件上传**: 使用 `c.FormFile("file")` 获取上传文件
5. **统一响应**: 所有接口返回 HTTP 200，通过 `status_code` 区分业务状态
